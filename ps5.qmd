---
title: "STATS 506 - Problem Set 4"
author: "Mina Dao"
format: html
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading Packages

```{r, warning = FALSE, message = FALSE}
library(dplyr)
library(ggplot2)
library(plotly)
library(tidyverse)
```

## Problem 1 - OOP Programming

#### a. define `waldCI` class

-   constructor

```{r}
setClass("waldCI", 
         slots = c(mean = "numeric",
                   se = "numeric",
                   lower = "numeric",
                   upper = "numeric",
                   conf = "numeric"))

waldCI <- function(mean = NULL, se = NULL, lower = NULL, upper = NULL, conf = 0.95) {
  has_mean_se <- !is.null(mean) && !is.null(se)
  has_bounds <- !is.null(lower) && !is.null(upper)
  
  if (has_mean_se) {
    z <- qnorm(1 - (1 - conf) / 2)
    margin_error <- z * se
    calc_lower <- mean - margin_error
    calc_upper <- mean + margin_error
  
    result <- new("waldCI", 
                  mean = mean, 
                  se = se, 
                  lower = calc_lower, 
                  upper = calc_upper, 
                  conf = conf)
  }
  
  if (has_bounds) {
    calc_mean <- (lower + upper) / 2
    z <- qnorm(1 - (1 - conf) / 2)
    calc_se <- (upper - lower) / (2 * z)
    
    result <- new("waldCI", 
                  mean = calc_mean, 
                  se = calc_se, 
                  lower = lower, 
                  upper = upper, 
                  conf = conf)
  }
  
  return(result)
}


```

-   `as.numeric` to return `c(lb, ub)` for a given `level`

```{r}
setMethod("as.numeric", signature(x = "waldCI"),
  function(x, level = x@conf, ...) {
    if (level <= 0 || level >= 1) {
      stop("Level must be between 0 and 1")
    }
    if (level != x@conf) {
      z <- qnorm(1 - (1 - level) / 2)
      margin_error <- z * x@se
      curr_lower <- x@mean - margin_error
      curr_upper <- x@mean + margin_error
    } else {
      curr_lower <- x@lower
      curr_upper <- x@upper
    }
    currCI <- c(curr_lower, curr_upper)
    return(currCI)
  }) 
```

-   validator

```{r}
setValidity("waldCI", function(object) {
  errors <- character()
  
  has_mean_se <- !is.null(object@mean) && !is.null(object@se)
  has_bounds <- !is.null(object@lower) && !is.null(object@upper)
  
  if (any(!is.finite(c(object@mean, object@se, object@lower, object@upper, object@conf)))) {
    errors <- c(errors, "All values must be finite (no NA, NaN, or Inf)")
  }
  
  if (object@conf <= 0 || object@conf >= 1) {
    errors <- c(errors, paste("@conf = ", object@conf, "is not between 0 and 1"))
    
  }
  if (object@lower >= object@upper) {
    errors <- c(errors, paste("@lower = ", object@lower, "is larger than @upper = ", object@upper))
  }
  
  if (object@se < 0) {
    errors <- c(errors, paste("@se = ", object@se, "is negative"))
  }
  
    if (!has_mean_se && !has_bounds) {
    errors <- c(errors, "Must provide either (mean and se) or (lower and upper bounds)")
  }
  
  if (has_mean_se && has_bounds) {
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    calc_lower <- object@mean - margin_error
    calc_upper <- object@mean + margin_error
    
    # float inconsistency
    if (abs(calc_lower - object@lower) > 1e-10 || abs(calc_upper - object@upper) > 1e-10) {
      errors <- c(errors, "Bounds are not consistent with mean and se")
    }
  }
  
  if (length(errors) == 0) {
    return(TRUE)
  } else {
    paste(errors, collapse = ", ")
  }
})

```

-   `show` method

```{r,error=TRUE}
# add more arguments to generic `show`
setGeneric("show",
           function(object, ...) {
             standardGeneric("show")
           })

##' @title Display a `waldCI` object
##' @param object A `waldCI` object,  
##' @param level confidence level of the object
##' @param digits number of displayed digits
setMethod("show", "waldCI",
  function(object, level = object@conf, digits = 4) {
    # validate display level
    if (level <= 0 || level >= 1) {
      cat("Level must be between 0 and 1")
      return(-1)
    }
    
    # calculate the bounds for different level 
    disp_bounds <- as.numeric(object, level)
    # output
    cat("Wald Confidence Interval\n")
    cat("Mean: ", round(object@mean, digits), "\n", sep = "")
    cat("Standard Error: ", round(object@se, digits), "\n", sep = "")
    
    cat(object@conf * 100, "% confidence interval: [", round(object@lower, digits), ", ", round(object@upper, digits), "]\n", sep = "")
    
    if (level != object@conf) {
      cat(level * 100, "% confidence interval: [", round(disp_bounds[1], digits), ", ", round(disp_bounds[2], digits), "]\n", sep = "")
    }
    
    return(invisible(object))
  }
)
```

-   assessors

```{r}
# lb 
setGeneric("lb",
           function(object,...) {
             standardGeneric("lb")
           })

##' @title return the lower bound of a `waldCI` object 
##' @param object A `waldCI` object  
##' @return the lower bound
setMethod("lb", "waldCI",
  function(object, level = object@conf) {
    if (level != object@conf) {
      curr_bounds <- as.numeric(object, level)
      return(curr_bounds[1])
    }
    return(slot(object, "lower"))
  })

# ub
setGeneric("ub",
           function(object,...) {
             standardGeneric("ub")
           })

##' @title return the upper bound of a `waldCI` object
##' @param object A `waldCI` object
##' @return the upper bound
setMethod("ub", "waldCI",
  function(object, level = object@conf) {
    if (level != object@conf) {
      curr_bounds <- as.numeric(object, level)
      return(curr_bounds[2])
    }
    return(slot(object, "upper"))
  })
```

```{r}
# mean
setGeneric("mean",
           function(object) {
             standardGeneric("mean")
           })
##' @title return the mean of a `waldCI` object
##' @param object A `waldCI` object
##' @return the mean
setMethod("mean", "waldCI",
  function(object) {
    return(slot(object, "mean"))
  }) 

# sterr
setGeneric("sterr",
           function(object) {
             standardGeneric("sterr")
           })
##' @title return the sterr of a `waldCI` object
##' @param object A `waldCI` object
##' @return the sterr
setMethod("sterr", "waldCI",
  function(object) {
    return(slot(object, "se"))
  }) 

# level
setGeneric("level",
           function(object) {
             standardGeneric("level")
           })
##' @title return the level of a `waldCI` object
##' @param object A `waldCI` object
##' @return the confidence level
setMethod("level", "waldCI",
  function(object) {
    return(slot(object, "conf"))
  }) 
```

-   setters

```{r}
# lb
setGeneric("lb<-",
           function(object, value) {
             standardGeneric("lb<-")
           })

##' @title set the lower bound of a `waldCI` object
##' @param object a `waldCI` object
##' @param value new bound
##' @return the updated object
setMethod("lb<-", "waldCI",
  function(object, value) {
    if (!is.numeric(value)) {
      stop("upper bound must be numeric")
    }
    # update value
    object@lower <- value
    
    # update object 
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    object@mean <- value + margin_error
    object@upper <- object@mean + margin_error
    
    validObject(object) # re-run validity check
    return(object)
  }
)

# ub
setGeneric("ub<-",
           function(object, value) {
             standardGeneric("ub<-")
           })

##' @title set the lower bound of a `waldCI` object
##' @param object a `waldCI` object
##' @param value new bound
##' @return the updated object
setMethod("ub<-", "waldCI",
  function(object, value) {
    if (!is.numeric(value)) {
      stop("Lower bound must be numeric")
    }
    # update value
    object@upper <- value
    
    # update object
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    object@mean <- value + margin_error
    object@lower <- object@mean - margin_error
    
    validObject(object) # re-run validity check
    return(object)
  }
)
```

```{r}
# mean
setGeneric("mean<-",
           function(object, value) {
             standardGeneric("mean<-")
           })

##' @title set the mean of a `waldCI` object
##' @param object a `waldCI` object
##' @param value new mean
##' @return the updated object
setMethod("mean<-", "waldCI",
  function(object, value) {
    if (!is.numeric(value)) {
      stop("Mean must be numeric")
    }
    # update value
    object@mean <- value
    
    # update object
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    object@lower <- object@mean - margin_error
    object@upper <- object@mean + margin_error
    
    validObject(object) # re-run validity check
    return(object)
  }
)

# sterr
setGeneric("sterr<-",
           function(object, value) {
             standardGeneric("sterr<-")
           })

##' @title set the sterr of a `waldCI` object
##' @param object a `waldCI` object
##' @param value new sterr
##' @return the updated object
setMethod("sterr<-", "waldCI",
  function(object, value) {
    if (value <= 0) {
      stop("Standard error must be greater than 0")
    }
    if (!is.numeric(value)) {
      stop("SE must be numeric")
    }
    # update value
    object@se <- value
    
    # update object
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    object@lower <- object@mean - margin_error
    object@upper <- object@mean + margin_error
    
    validObject(object) # re-run validity check
    return(object)
  }
)

# level
setGeneric("level<-",
           function(object, value) {
             standardGeneric("level<-")
           })

##' @title set the level of a `waldCI` object
##' @param object a `waldCI` object
##' @param value new level
##' @return the updated object
setMethod("level<-", "waldCI",
  function(object, value) {
    if (value <= 0 || value >= 1) {
      stop("Level must be between 0 and 1")
    }
    if (!is.numeric(value)) {
      stop("Level must be numeric")
    }
    
    # update value
    object@conf <- value
    
    # update object
    z <- qnorm(1 - (1 - object@conf) / 2)
    margin_error <- z * object@se
    object@lower <- object@mean - margin_error
    object@upper <- object@mean + margin_error
    
    validObject(object) # re-run validity check
    return(object)
  }
)
```

-   `contains` method

```{r}
setGeneric("contains",
           function(object, value, level = object@level) {
             standardGeneric("contains")
           })

##' @title checking whether a value is within a CI of a `waldCI` object
##' @param object a `waldCI` object
##' @param value value to check
##' @param level confidence level of the CI
##' @return a logical
setMethod("contains", "waldCI",
  function(object, value, level = object@conf) {
    curr_bounds <- as.numeric(object, level)
    curr_lb <- curr_bounds[1]
    curr_ub <- curr_bounds[2]
    if (value <= curr_ub && value >= curr_lb) {
      return(TRUE)
    }
    return(FALSE)
  }
)
```

-   `overlap` method

```{r}
setGeneric("overlap",
           function(object1, object2, level = NULL) {
             standardGeneric("overlap")
           })

##' @title checking whether two `waldCI` objects have overlapping intervals
##' @param object1 a `waldCI` object
##' @param object2 a `waldCI` object
##' @param level confidence level 
##' @return a logical 
setMethod("overlap", "waldCI",
  function(object1, object2, level = NULL) {
    if (!is.null(level)) {
      object1_bounds <- as.numeric(object1, level)
      object1_lb <- object1_bounds[1]
      object1_ub <- object1_bounds[2]
      
      object2_bounds <- as.numeric(object2, level)
      object2_lb <- object2_bounds[1]
      object2_ub <- object2_bounds[2]
    } else {
      object1_lb <- object1@lower
      object1_ub <- object1@upper
      object2_lb <- object2@lower
      object2_ub <- object2@upper
    }  
      
    if (object1_lb < object2_lb) {
      if(object1_ub >= object2_lb) {
        return(TRUE)
      } else {
        return(FALSE)
      }
    }
    
    if (contains(object2, object1_lb)) {
      return(TRUE)
    }
    
    if (object1_lb > object2_ub) {
      return(FALSE)
    }
})
```

-   `transformCI` function

```{r}
setGeneric("transformCI", 
           function(object, FUN) {
             standardGeneric("transformCI")
           })
setMethod("transformCI", "waldCI",
  function(object, FUN) {
    if (!is.function(FUN)) {
      cat(FUN, " is not a function", sep = "")
      stop()
    }
    
    # check if the function is monotonic on the interval
    test_interval <- seq(object@lower, object@upper, length.out = 10)
    test_vals <- FUN(test_interval)
    
    if (!(all(diff(test_vals) >= 0) || !(all(diff(test_vals) <= 0)))) {
      warning("Function is not monotonic on the confidence interval")
    }
    
    # transform the bound
    new_lb <- FUN(object@lower)
    new_ub <- FUN(object@upper)
    new_mean <- FUN(object@mean)
    
    # transform the standard error by taking derivatives
    h <- 1e-10  
    derivative <- (FUN(object@mean + h) - FUN(object@mean)) / h
    new_se <- abs(derivative) * object@se
    
    result <- waldCI(
      lower = min(new_lb, new_ub),
      upper = max(new_lb, new_ub),
      se = new_se,
      mean = new_mean,
      conf = object@conf
    )
    return(result)
  })
```

#### b. Create objects

```{r}
ci1 <- waldCI(lower = 17.2, upper = 24.7)
ci2 <- waldCI(mean = 12, se = 2.5, conf = 0.99)
ci3 <- waldCI(lower = 27.43, upper = 39.22, conf = 0.75)
```

Evaluate the code

```{r}
ci1
ci2
ci3
as.numeric(ci1)
as.numeric(ci2)
as.numeric(ci3)
lb(ci2)
ub(ci2)
mean(ci1)
sterr(ci3)
level(ci2)
lb(ci2) <- 10.5
mean(ci3) <- 34
level(ci3) <- .8
contains(ci1, 17)
contains(ci3, 44)
overlap(ci1, ci2)
eci1 <- transformCI(ci1, sqrt)
eci1
mean(transformCI(ci2, log))
```

#### c. Show the validator does not allow creation of invalid confidence intervals

```{r}
# negative standard error
cat("Testing negative standard error:\n")
tryCatch({
  ci_bad1 <- waldCI(mean = 2, se = -2)
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked:", e$message, "\n")
})
cat("\n")

# lb > ub
cat("Testing lower bound > upper bound:\n")
tryCatch({
  ci_bad2 <- waldCI(lower = 8, upper = 5)
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked:", e$message, "\n")
})
cat("\n")

# infinite bounds
cat("Testing infinite bounds:\n")
tryCatch({
  ci_bad3 <- waldCI(lower = -Inf, upper = 5)
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked:", e$message, "\n")
})

tryCatch({
  ci_bad4 <- waldCI(lower = 5, upper = Inf)
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked:", e$message, "\n")
})
cat("\n")

# inconsistent mean/se with bounds
cat("Testing inconsistent mean/se with bounds:\n")
tryCatch({
  # create inconsistent object using new()
  ci_bad5 <- new("waldCI", 
                  mean = 10, 
                  se = 2, 
                  lower = 1,    # This doesn't match mean ± z*se
                  upper = 19, 
                  conf = 0.95)
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked:", e$message, "\n")
})
cat("\n")

# invalid use of setters
cat("Testing invalid setter usage:\n")

# create a valid object
ci_valid <- waldCI(mean = 10, se = 2)
cat("Created valid object:\n")
print(ci_valid)

# try to set invalid standard error
cat("Setting negative standard error:\n")
tryCatch({
  sterr(ci_valid) <- -1
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked setter:", e$message, "\n")
})
cat("\n")

# try to set invalid confidence level 
cat("Setting bounds with invalid confidence level:\n")
tryCatch({
  level(ci_valid) <- -2
  cat("ERROR: Should have failed but didn't!\n")
}, error = function(e) {
  cat("Correctly blocked setter:", e$message, "\n")
})
cat("\n")


```

## Problem 3 - plotly

```{r}
covid_data <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv")
str(covid_data)
```

```{r}
# direct download of Census population estimates
census_url <- "https://www2.census.gov/programs-surveys/popest/datasets/2020-2023/state/totals/NST-EST2023-ALLDATA.csv"
state_populations <- read.csv(census_url) %>%
  filter(STATE != 0) %>%  # remove US total
  rename(
    state = NAME,
    population = POPESTIMATE2023
  ) %>%
  select(state, population)

# filter COVID data to only include 50 states + DC (exclude territories)
states_dc <- state_populations %>%
  select(state)
covid_data_states <- covid_data %>%
  filter(state %in% states_dc)

# convert date and ensure proper formatting
covid_data <- covid_data %>%
  mutate(date = ymd(date)) %>%
  arrange(date)

# convert numeric columns from character to numeric
covid_data <- covid_data %>%
  mutate(across(c(cases_avg, cases_avg_per_100k, deaths_avg, 
                  deaths_avg_per_100k), 
                as.numeric))

covid_data <- covid_data %>% arrange(date)

# merge population data and calculate cases per 100k
covid_data <- covid_data %>% 
  left_join(state_populations, by = "state") %>%
  mutate(cases_per_100k = (cases_avg / population) * 100000)

```

#### a.

```{r, warning = FALSE, fig.width=8, fig.height=6}
us_states_date <- covid_data%>%
  group_by(date) %>%
  summarise(total_cases = sum(cases))
  
us_states_week <- covid_data %>%
  mutate(week = floor_date(date, "week")) %>%
  group_by(week) %>%
  summarise(cases_week_avg = sum(cases) / 7)

p1_plotly <- plot_ly() %>%
  # Add line (weekly average with color mapping)
  add_trace(
    data = us_states_week,
    x = ~week,
    y = ~cases_week_avg,
    type = "scatter",
    mode = "lines",
    line = list(width = 2),
    marker = NULL,
    name = "Weekly Average",
    showlegend = FALSE
  ) %>%
  # Layout configuration
  layout(
    title = (
      text = "COVID-19 Cases in the United States: Major and Minor Spikes"),
    xaxis = list(
      title = "",
      type = "date",
      range = c("2020-01-01", "2023-12-31")),
    yaxis = list(
      title = "Average Cases Per Week",
      tickformat = ","
    )
  )
p1_plotly
```
I can detect 4 major spikes and 3 minor spikes.

## b. 

```{r, fig.width=8, fig.height=6}
covid_state <- covid_data %>%
  group_by(state) %>%
  summarize(total = sum(cases_avg_per_100k)) %>%
  ungroup()

# Find min and max values for conditional formatting
max_total <- max(covid_state$total, na.rm = TRUE)
min_total <- min(covid_state$total, na.rm = TRUE)

p_plotly <- plot_ly(covid_state, x = ~total, y = ~state) %>%
  # Add points with conditional coloring
  add_trace(
    type = "scatter",
    mode = "markers",
    marker = list(
      color = ~ifelse(total == max_total | total == min_total, "salmon", "blue"),
      size = 8
    ),
    showlegend = FALSE
  ) %>%
  # Add text labels with conditional positioning
  add_trace(
    type = "scatter",
    mode = "text",
    text = ~state,
    textposition = ~ifelse(total > 40000, "middle left", "middle right"),
    textfont = list(size = 12),
    showlegend = FALSE
  ) %>%
  # Layout configuration
  layout(
    xaxis = list(
      title = "Total COVID cases 01/2020-03/2023"
    ),
    yaxis = list(
      title = "",
      showticklabels = FALSE,
      showgrid = FALSE
    ),
    showlegend = FALSE
  )

p_plotly
```

We can see that Maine and Rhode Island are the lowest and highest overall.

```{r, fig.width=8, fig.height=6}
filtered_covid <- covid_data %>% 
  filter(state == "Maine" | state == "Rhode Island")

p2_plotly <- plot_ly(filtered_covid, x = ~date, y = ~cases_avg_per_100k, 
                    color = ~state) %>%
  add_trace(
    type = "scatter",
    mode = "lines", 
    line = list(width = 2)
  ) %>%
  layout(
    title = (
      text = "US States with Highest and Lowest Overall Rates Per Population"),
    yaxis = list(title = "COVID cases per 100k"),
    legend = list(
      x = 0.9,      # 90% from left
      y = 0.9,      # 90% from bottom  
      xanchor = "center",
      yanchor = "center",
      bordercolor = "rgba(0,0,0,0.2)",
      borderwidth = 1
    )
  )
p2_plotly
```

In winter 21-22, while the count in Rhode Island increased 10-fold, Maine did not seem to be affected.

#### c.

```{r, warning = FALSE, fig.height= 6, fig.width = 8}
us_states_start <- covid_data %>%
  filter(date > as.Date("2020-03-20"), 
         date < as.Date("2020-04-20"),
         cases_avg_per_100k > 15)

p3_plotly <- plot_ly(us_states_start, 
                     x = ~date, 
                     y = ~cases_avg_per_100k, 
                     color = ~state,
                     type = 'scatter',
                     mode = 'lines',
                     line = list(width = 2)) %>%
  layout(
    title = (text = "COVID-19 Case Rates by State (Mar – Apr 2020)"),
    xaxis = list(
      title = "",
      range = c(as.Date("2020-03-20"), as.Date("2020-04-20"))
    ),
    yaxis = list(
      title = "Average Cases per 100k",
      range = c(15, 60)
    ),
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.3,
      yanchor = "top",
      title = list(text = "State")
    )
  )

p3_plotly
```
We see that New York, New Jersey, Louisiana, and Guam are the first experience Covid substantially.


Distribution of sources:

1.  Using R to Find Confidence Intervals
    https://chem.libretexts.org/Bookshelves/Analytical_Chemistry/Chemometrics_Using_R\_(Harvey)/06%3A_Uncertainty_of_Data/6.04%3A_Using_R_to_Find_Confidence_Intervals
    
2.  Back-transform Standard Error
    https://vsni.co.uk/back-transform-standard-error/
    
3.  Line Plots in R https://plotly.com/r/line-charts/

